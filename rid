#!/usr/bin/env ruby
# frozen_string_literal: true

require 'etc'
require 'yaml'
require 'shellwords'

# Encapsulates a docker command.
class Docker
  attr_reader :command, :options, :args

  def initialize(command)
    @command = command

    @options = Hash.new do |hash, key|
      hash[key] = []
    end

    @args = []
  end

  # Docker command as an array.
  def command_array
    options = []
    @options.each_pair do |key, values|
      switch = key.length == 1 ? "-#{key}" : "--#{key}"

      # Treat Non array-like values as a single value.
      values = [values] unless values.respond_to?('each')

      values.each do |value|
        options << switch

        # If the value is true, it's considered an option without a
        # value. Everything else is `to_s`ed.
        options << value.to_s if value != true
      end
    end

    ['docker', @command, *options, *@args.flatten]
  end

  # Args as a string.
  def args_to_s
    @args.flatten.shelljoin
  end

  # Docker command string.
  def to_s
    command_array.shelljoin
  end

  # Run docker command.
  def run
    system(*command_array)
  end

  # Exec docker command.
  def exec
    Process.exec(*command_array)
  end
end

# Handles global config
class Config
  attr_reader :root

  def initialize(path, config, parent)
    @root = path
    @config = config || {}
    @parent = parent
  end

  def [](key)
    @config[key]
  end

  def command(name)
    command = command_hash(name)
    abort "rid: unknown program #{name}" unless command

    Command.new(self, name, command)
  end

  def command_hash(name)
    command = @config.dig(:commands, name.intern)

    if command
      # Merge in options if we inherit.
      command = command_inherit(name, command)
    elsif @parent
      # Use definition from parent configs if we didn't have the
      # command.
      command ||= @parent.command_hash(name)
    end

    command
  end

  def command_inherit(name, command)
    # Merge in options if we inherit.
    return command unless command[:inherit]

    inherit_from = if command[:inherit].is_a? String
                     command_hash(command[:inherit])
                   else
                     @parent.command_hash(name)
                   end

    abort 'rid: could not find command to inherit from' unless inherit_from

    inherit_from.merge(command)
  end
end

# Handles the nitty-gritty of docker command setup.
class Command
  attr_accessor :run_shell
  attr_reader :name, :user_args, :additional_options

  def initialize(config_file, name, config)
    @config_file = config_file
    @config = config
    @name = name
    abort "rid: no image given for #{@name}" unless config[:image]
    @user_args = []
    @additional_options = []
    # Allow single value cache.
    @caches = config[:cache] ? Array(config[:cache]) : []
    @mounts = config[:mount] ? Array(config[:mount]) : []
    @mount_args = config[:mount_args] ? Array(config[:mount_args]) : []
    @env_vars = config[:env] ? Array(config[:env]) : []
  end

  # Return the docker command.
  def command
    docker = Docker.new('run')

    # Basic options.
    docker.options['rm'] = true unless @config[:keep]
    docker.options['interactive'] = true
    docker.options['tty'] = true if $stdin.tty?

    # Networking
    docker.options['network'] = @config[:network] if @config[:network]

    # Volumes and cache directories.
    @mounts.each do |mountpoint|
      docker.options['volume'] << "#{mountpoint}:#{mountpoint}"
    end

    @caches.each do |name|
      name.gsub!(/\$USER/, Etc.getlogin)
      cache_dir = ensure_cachedir(name)
      docker.options['volume'] << "#{cache_dir}:#{name}"
    end

    # "Environment cloning", that is, give the command an environment
    # that looks as much as possible that it's running locally.
    unless @config[:raw]
      docker.options['init'] = true
      docker.options['user'] = "#{Process.uid}:#{Process.gid}"
      docker.options['workdir'] = Dir.pwd
      docker.options['volume'] << "#{@config_file.root}:#{@config_file.root}"

      env_vars = %w[HOME USER USERNAME LOGNAME].append(*@env_vars).collect { |var| ENV.include?(var) ? var : nil }.compact
      env_vars.each do |x|
        docker.options['env'] << x
      end
    end

    # Set entrypoint and image arg.
    docker.options['entrypoint'] = @config[:entrypoint] if @config[:entrypoint]

    docker.args << @config[:image]

    mount_args = @mount_args.map { |mount_arg| Regexp.new(mount_arg) }

    # Handle args from config and command line. Also running a shell
    # instead.
    if !@run_shell
      args = (@config[:args] || '').shellsplit + @user_args

      # Add mounts for arguments matching mount_args.
      args.each do |arg|
        mount_args.each do |mount_arg|
          docker.options['volume'] << "#{arg}:#{arg}" if arg =~ mount_arg
        end

        docker.args << arg
      end
    else
      docker.options['entrypoint'] = 'sh'
      '-c "if [ -e /usr/bin/fish ]; then exec /usr/bin/fish; elif [ -e /bin/bash ]; then exec /bin/bash; else exec /bin/sh; fi"'.shellsplit.each do |arg|
        docker.args << arg
      end
    end

    # Handle port from args.
    if @config[:port_from_args]
      abort "rid: invalid port_from_args regexp \"#{@config[:port_from_args]}\"" unless
        @config[:port_from_args] =~ %r{^/(.*)/$}

      regexp = Regexp.last_match(1)

      abort "rid: invalid port_from_args regexp \"#{regexp}\" didn't match args \"#{args}\"" unless
        docker.args_to_s =~ Regexp.new(regexp)

      port = Regexp.last_match(1)

      abort "rid: invalid port_from_args port number \"#{port}\"" unless port =~ /^\d+$/

      docker.options['publish'] << "#{port}:#{port}"
    end

    docker
  end

  # Ensure a cache directory exists.
  def ensure_cachedir(name)
    # Ensure that the .cache directory exists, just in case.
    Dir.mkdir(XDG_CACHE_DIR) unless File.exist? XDG_CACHE_DIR
    # Same for our cache directory.
    Dir.mkdir(CACHE_DIR) unless File.exist? CACHE_DIR
    # Create a directory per command.
    cache_root = File.join(CACHE_DIR, @name)
    Dir.mkdir(cache_root) unless File.exist? cache_root
    # And a directory per cache spec.
    cache_dir = File.join(cache_root, name.gsub(%r{/}, '!'))
    Dir.mkdir(cache_dir) unless File.exist? cache_dir
    cache_dir
  end
end

XDG_CACHE_DIR = ENV.include?('XDG_CACHE_HOME') ? ENV['XDG_CACHE_HOME'] : File.expand_path('~/.cache')

name = File.basename($PROGRAM_NAME)

run_shell = false
dry_run = false

if name == 'rid'
  name = ARGV.shift

  while name =~ /^-/
    case name
    when '-s', '--shell'
      run_shell = true
    when '-n', '--dry-run'
      dry_run = true
    else
      abort("rid: unknown option #{name}")
    end

    name = ARGV.shift
  end

end

abort 'rid: no command given' unless name

CACHE_DIR = File.join(XDG_CACHE_DIR, 'rid').freeze

config_files = []

dir = Dir.pwd
while dir != '/'
  file = File.join(dir, '.rid.yml')

  config_files << file if File.exist?(file)

  dir = File.dirname(dir)
end

abort('rid: no config file found') if config_files.empty?

config_files.reverse!

config = nil
config_files.each do |file_name|
  begin
    config_hash = YAML.safe_load(File.read(file_name), symbolize_names: true, filename: file_name)
  rescue StandardError => e
    abort "rid: error loading config file: #{e.message}"
  end

  config = Config.new(File.dirname(file_name), config_hash, config)
end

command = config.command(name)

command.user_args.push *ARGV
command.run_shell = run_shell

puts "rid: would run: #{command.command}" if dry_run

command.command.exec unless dry_run
